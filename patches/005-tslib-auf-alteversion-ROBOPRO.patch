From b19e3bf601345cec98d1ef205222c1848581c203 Mon Sep 17 00:00:00 2001
From: Reinhard Russinger <reinhard@russinger.at>
Date: Wed, 9 Sep 2020 11:27:06 +0000
Subject: [PATCH] tslib-auf-alteversion-ROBOPRO

---
 ...x-build-on-32bit-arches-with-64bit-time_t.patch | 386 -----------
 ...error-with-input_event_sec-for-old-kernel.patch |  28 -
 package/tslib/Config.in                            |   8 +-
 package/tslib/tslib-enable_raw_module.patch        |  14 +
 package/tslib/tslib.hash                           |   5 -
 package/tslib/tslib.mk                             |  27 +-
 .../tslib_add_finddef_and_inputattach_utils.patch  | 718 +++++++++++++++++++++
 7 files changed, 742 insertions(+), 444 deletions(-)
 delete mode 100644 package/tslib/0001-Fix-build-on-32bit-arches-with-64bit-time_t.patch
 delete mode 100644 package/tslib/0002-Fix-build-error-with-input_event_sec-for-old-kernel.patch
 create mode 100644 package/tslib/tslib-enable_raw_module.patch
 delete mode 100644 package/tslib/tslib.hash
 create mode 100644 package/tslib/tslib_add_finddef_and_inputattach_utils.patch

diff --git a/package/tslib/0001-Fix-build-on-32bit-arches-with-64bit-time_t.patch b/package/tslib/0001-Fix-build-on-32bit-arches-with-64bit-time_t.patch
deleted file mode 100644
index 70a3f25..0000000
--- a/package/tslib/0001-Fix-build-on-32bit-arches-with-64bit-time_t.patch
+++ /dev/null
@@ -1,386 +0,0 @@
-From 09eeff8c90a82e7aa9ff215320d558c1147982f6 Mon Sep 17 00:00:00 2001
-From: Khem Raj <raj.khem@gmail.com>
-Date: Sat, 30 Nov 2019 19:59:29 -0800
-Subject: [PATCH] Fix build on 32bit arches with 64bit time_t
-
-time element is deprecated on new input_event structure in kernel's
-input.h [1]
-
-[1] https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=152194fe9c3f
-
-Signed-off-by: Khem Raj <raj.khem@gmail.com>
-Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
-[Upstream status: https://github.com/libts/tslib/commit/a7a39a67f9a7f7fab9765d412ab42869a5c5c858]
----
- plugins/input-raw.c | 59 +++++++++++++++++++++++++++-------------
- tools/ts_uinput.c   | 66 ++++++++++++++++++++++++++++++---------------
- 2 files changed, 85 insertions(+), 40 deletions(-)
-
-diff --git a/plugins/input-raw.c b/plugins/input-raw.c
-index 64f0156..f030836 100644
---- a/plugins/input-raw.c
-+++ b/plugins/input-raw.c
-@@ -40,6 +40,11 @@
- # include <linux/input.h>
- #endif
- 
-+#ifndef input_event_sec
-+#define input_event_sec time.tv_sec
-+#define input_event_usec time.tv_usec
-+#endif
-+
- #ifndef EV_SYN /* 2.4 kernel headers */
- # define EV_SYN 0x00
- #endif
-@@ -384,7 +389,8 @@ static int ts_input_read(struct tslib_module_info *inf,
- 						samp->y = i->current_y;
- 						samp->pressure = i->current_p;
- 					}
--					samp->tv = ev.time;
-+					samp->tv.tv_sec = ev.input_event_sec;
-+					samp->tv.tv_usec = ev.input_event_usec;
- 			#ifdef DEBUG
- 				fprintf(stderr,
- 					"RAW---------------------> %d %d %d %ld.%ld\n",
-@@ -519,7 +525,8 @@ static int ts_input_read(struct tslib_module_info *inf,
- 					samp->pressure = i->current_p = ev.value;
- 					break;
- 				}
--				samp->tv = ev.time;
-+				samp->tv.tv_sec = ev.input_event_sec;
-+				samp->tv.tv_usec = ev.input_event_usec;
- 	#ifdef DEBUG
- 				fprintf(stderr,
- 					"RAW---------------------------> %d %d %d\n",
-@@ -536,7 +543,8 @@ static int ts_input_read(struct tslib_module_info *inf,
- 						samp->x = 0;
- 						samp->y = 0;
- 						samp->pressure = 0;
--						samp->tv = ev.time;
-+						samp->tv.tv_sec = ev.input_event_sec;
-+						samp->tv.tv_usec = ev.input_event_usec;
- 						samp++;
- 						total++;
- 					}
-@@ -651,7 +659,8 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 				switch (i->ev[it].code) {
- 				case BTN_TOUCH:
- 					i->buf[total][i->slot].pen_down = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					if (i->ev[it].value == 0)
- 						pen_up = 1;
-@@ -751,7 +760,8 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					// fall through
- 				case ABS_MT_POSITION_X:
- 					i->buf[total][i->slot].x = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_Y:
-@@ -760,7 +770,8 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					// fall through
- 				case ABS_MT_POSITION_Y:
- 					i->buf[total][i->slot].y = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_PRESSURE:
-@@ -769,12 +780,14 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					// fall through
- 				case ABS_MT_PRESSURE:
- 					i->buf[total][i->slot].pressure = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_TOOL_X:
- 					i->buf[total][i->slot].tool_x = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					/* for future use
- 					 * i->buf[total][i->slot].valid |= TSLIB_MT_VALID_TOOL;
-@@ -782,7 +795,8 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					break;
- 				case ABS_MT_TOOL_Y:
- 					i->buf[total][i->slot].tool_y = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					/* for future use
- 					 * i->buf[total][i->slot].valid |= TSLIB_MT_VALID_TOOL;
-@@ -790,7 +804,8 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					break;
- 				case ABS_MT_TOOL_TYPE:
- 					i->buf[total][i->slot].tool_type = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					/* for future use
- 					 * i->buf[total][i->slot].valid |= TSLIB_MT_VALID_TOOL;
-@@ -798,12 +813,14 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					break;
- 				case ABS_MT_ORIENTATION:
- 					i->buf[total][i->slot].orientation = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_DISTANCE:
- 					i->buf[total][i->slot].distance = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 
- 					if (i->special_device == EGALAX_VERSION_210) {
-@@ -816,34 +833,40 @@ static int ts_input_read_mt(struct tslib_module_info *inf,
- 					break;
- 				case ABS_MT_BLOB_ID:
- 					i->buf[total][i->slot].blob_id = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_TOUCH_MAJOR:
- 					i->buf[total][i->slot].touch_major = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					if (i->ev[it].value == 0)
- 						i->buf[total][i->slot].pressure = 0;
- 					break;
- 				case ABS_MT_WIDTH_MAJOR:
- 					i->buf[total][i->slot].width_major = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_TOUCH_MINOR:
- 					i->buf[total][i->slot].touch_minor = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_WIDTH_MINOR:
- 					i->buf[total][i->slot].width_minor = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					break;
- 				case ABS_MT_TRACKING_ID:
- 					i->buf[total][i->slot].tracking_id = i->ev[it].value;
--					i->buf[total][i->slot].tv = i->ev[it].time;
-+					i->buf[total][i->slot].tv.tv_sec = i->ev[it].input_event_sec;
-+					i->buf[total][i->slot].tv.tv_usec = i->ev[it].input_event_usec;
- 					i->buf[total][i->slot].valid |= TSLIB_MT_VALID;
- 					if (i->ev[it].value == -1)
- 						i->buf[total][i->slot].pressure = 0;
-diff --git a/tools/ts_uinput.c b/tools/ts_uinput.c
-index 6ca4c3d..1832a07 100644
---- a/tools/ts_uinput.c
-+++ b/tools/ts_uinput.c
-@@ -170,14 +170,16 @@ static int send_touch_events(struct data_t *data, struct ts_sample_mt **s,
- 				continue;
- 
- 			if (s[j][i].pen_down == 1) {
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_KEY;
- 				data->ev[c].code = BTN_TOUCH;
- 				data->ev[c].value = s[j][i].pen_down;
- 				c++;
- 			}
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_SLOT;
- 			data->ev[c].value = s[j][i].slot;
-@@ -190,111 +192,129 @@ static int send_touch_events(struct data_t *data, struct ts_sample_mt **s,
- 			 * we should use slot 1 and so on.
- 			 */
- 			if (i == 0) {
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_ABS;
- 				data->ev[c].code = ABS_X;
- 				data->ev[c].value = s[j][i].x;
- 				c++;
- 
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_ABS;
- 				data->ev[c].code = ABS_Y;
- 				data->ev[c].value = s[j][i].y;
- 				c++;
- 
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_ABS;
- 				data->ev[c].code = ABS_PRESSURE;
- 				data->ev[c].value = s[j][i].pressure;
- 				c++;
- 			}
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_POSITION_X;
- 			data->ev[c].value = s[j][i].x;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_POSITION_Y;
- 			data->ev[c].value = s[j][i].y;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_PRESSURE;
- 			data->ev[c].value = s[j][i].pressure;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TOUCH_MAJOR;
- 			data->ev[c].value = s[j][i].touch_major;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_WIDTH_MAJOR;
- 			data->ev[c].value = s[j][i].width_major;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TOUCH_MINOR;
- 			data->ev[c].value = s[j][i].touch_minor;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_WIDTH_MINOR;
- 			data->ev[c].value = s[j][i].width_minor;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TOOL_TYPE;
- 			data->ev[c].value = s[j][i].tool_type;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TOOL_X;
- 			data->ev[c].value = s[j][i].tool_x;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TOOL_Y;
- 			data->ev[c].value = s[j][i].tool_y;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_ORIENTATION;
- 			data->ev[c].value = s[j][i].orientation;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_DISTANCE;
- 			data->ev[c].value = s[j][i].distance;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_BLOB_ID;
- 			data->ev[c].value = s[j][i].blob_id;
- 			c++;
- 
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_ABS;
- 			data->ev[c].code = ABS_MT_TRACKING_ID;
- 			data->ev[c].value = s[j][i].tracking_id;
- 			c++;
- 
- 			if (data->mt_type_a == 1) {
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_SYN;
- 				data->ev[c].code = SYN_MT_REPORT;
- 				data->ev[c].value = 0;
-@@ -302,7 +322,8 @@ static int send_touch_events(struct data_t *data, struct ts_sample_mt **s,
- 			}
- 
- 			if (s[j][i].pen_down == 0) {
--				data->ev[c].time = s[j][i].tv;
-+				data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+				data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 				data->ev[c].type = EV_KEY;
- 				data->ev[c].code = BTN_TOUCH;
- 				data->ev[c].value = s[j][i].pen_down;
-@@ -312,7 +333,8 @@ static int send_touch_events(struct data_t *data, struct ts_sample_mt **s,
- 		}
- 
- 		if (c > 0) {
--			data->ev[c].time = s[j][i].tv;
-+			data->ev[c].input_event_sec = s[j][i].tv.tv_sec;
-+			data->ev[c].input_event_usec = s[j][i].tv.tv_usec;
- 			data->ev[c].type = EV_SYN;
- 			data->ev[c].code = SYN_REPORT;
- 			data->ev[c].value = 0;
diff --git a/package/tslib/0002-Fix-build-error-with-input_event_sec-for-old-kernel.patch b/package/tslib/0002-Fix-build-error-with-input_event_sec-for-old-kernel.patch
deleted file mode 100644
index 5dca3a0..0000000
--- a/package/tslib/0002-Fix-build-error-with-input_event_sec-for-old-kernel.patch
+++ /dev/null
@@ -1,28 +0,0 @@
-From 050bf24c16e95f63a76e13156346a072035d45b4 Mon Sep 17 00:00:00 2001
-From: Evan Harvey <evanwork1234@gmail.com>
-Date: Thu, 19 Mar 2020 01:32:03 -0700
-Subject: [PATCH] Fix build error with input_event_sec for old kernel
-
-[Retrieved from:
-https://github.com/libts/tslib/commit/050bf24c16e95f63a76e13156346a072035d45b4]
-Signed-off-by: Fabrice Fontaine <fontaine.fabrice@gmail.com>
----
- tools/ts_uinput.c | 5 +++++
- 1 file changed, 5 insertions(+)
-
-diff --git a/tools/ts_uinput.c b/tools/ts_uinput.c
-index 1832a07..9c40bb3 100644
---- a/tools/ts_uinput.c
-+++ b/tools/ts_uinput.c
-@@ -51,6 +51,11 @@
- #include <linux/fb.h>
- #endif
- 
-+#ifndef input_event_sec
-+#define input_event_sec time.tv_sec
-+#define input_event_usec time.tv_usec
-+#endif
-+
- #define RESET   "\033[0m"
- #define RED     "\033[31m"
- #define GREEN   "\033[32m"
diff --git a/package/tslib/Config.in b/package/tslib/Config.in
index a2e1e7f..ee70807 100644
--- a/package/tslib/Config.in
+++ b/package/tslib/Config.in
@@ -1,6 +1,10 @@
 config BR2_PACKAGE_TSLIB
 	bool "tslib"
+	depends on !BR2_PREFER_STATIC_LIB # dlopen
 	help
-	  Tslib is a filtering layer for touchscreen panel events.
+	  Tslib is an abstraction layer for touchscreen panel events.
 
-	  http://tslib.org
+	  https://github.com/kergoth/tslib
+
+comment "tslib needs a toolchain w/ dynamic library"
+	depends on BR2_PREFER_STATIC_LIB
diff --git a/package/tslib/tslib-enable_raw_module.patch b/package/tslib/tslib-enable_raw_module.patch
new file mode 100644
index 0000000..cb89338
--- /dev/null
+++ b/package/tslib/tslib-enable_raw_module.patch
@@ -0,0 +1,14 @@
+Enable raw module by default
+
+Signed-off-by: Daniel Nystr√∂m <daniel.nystrom@timeterminal.se>
+
+diff -Naur tslib-e000d35a.orig/etc/ts.conf tslib-e000d35a/etc/ts.conf
+--- tslib-e000d35a.orig/etc/ts.conf	2010-12-21 18:54:45.000000000 +0100
++++ tslib-e000d35a/etc/ts.conf	2010-12-21 18:55:03.000000000 +0100
+@@ -1,5 +1,5 @@
+ # Uncomment if you wish to use the linux input layer event interface
+-# module_raw input
++module_raw input
+ 
+ # Uncomment if you're using a Sharp Zaurus SL-5500/SL-5000d
+ # module_raw collie
diff --git a/package/tslib/tslib.hash b/package/tslib/tslib.hash
deleted file mode 100644
index 521e6c9..0000000
--- a/package/tslib/tslib.hash
+++ /dev/null
@@ -1,5 +0,0 @@
-# https://github.com/libts/tslib/releases/download/1.21/tslib-1.21.tar.xz.sha256
-sha256  d2a57b823ea59e53a3b130eef05dfed1190b857854f886eec764e1ca1957cf56  tslib-1.21.tar.xz
-
-# Locally computed
-sha256  9b872a8a070b8ad329c4bd380fb1bf0000f564c75023ec8e1e6803f15364b9e9  COPYING
diff --git a/package/tslib/tslib.mk b/package/tslib/tslib.mk
index 3a1b7a2..51aaf23 100644
--- a/package/tslib/tslib.mk
+++ b/package/tslib/tslib.mk
@@ -4,32 +4,13 @@
 #
 ################################################################################
 
-TSLIB_VERSION = 1.21
-TSLIB_SITE = https://github.com/libts/tslib/releases/download/$(TSLIB_VERSION)
-TSLIB_SOURCE = tslib-$(TSLIB_VERSION).tar.xz
-TSLIB_LICENSE = GPL-2.0+ (programs), LGPL-2.1+ (libraries)
+TSLIB_VERSION = 1.1
+TSLIB_SITE = $(call github,kergoth,tslib,$(TSLIB_VERSION))
+TSLIB_LICENSE = GPL, LGPL
 TSLIB_LICENSE_FILES = COPYING
 
+TSLIB_AUTORECONF = YES
 TSLIB_INSTALL_STAGING = YES
 TSLIB_INSTALL_STAGING_OPTS = DESTDIR=$(STAGING_DIR) LDFLAGS=-L$(STAGING_DIR)/usr/lib install
 
-ifeq ($(BR2_TOOLCHAIN_HEADERS_AT_LEAST_3_6),)
-TSLIB_CONF_OPTS += --disable-tools
-endif
-
-ifeq ($(BR2_STATIC_LIBS),y)
-TSLIB_CONF_OPTS += \
-	--enable-input=static \
-	--enable-linear=static \
-	--enable-median=static \
-	--enable-pthres=static \
-	--enable-iir=static \
-	--enable-dejitter=static \
-	--enable-debounce=static \
-	--enable-skip=static \
-	--enable-lowpass=static \
-	--enable-invert=static \
-	--enable-evthres=static
-endif
-
 $(eval $(autotools-package))
diff --git a/package/tslib/tslib_add_finddef_and_inputattach_utils.patch b/package/tslib/tslib_add_finddef_and_inputattach_utils.patch
new file mode 100644
index 0000000..dcc6ec7
--- /dev/null
+++ b/package/tslib/tslib_add_finddef_and_inputattach_utils.patch
@@ -0,0 +1,718 @@
+diff -Naur tslib-org/tests/Makefile.am tslib-1.0/tests/Makefile.am
+--- tslib-org/tests/Makefile.am	2006-08-25 00:02:55.000000000 +0300
++++ tslib-1.0/tests/Makefile.am	2007-05-07 17:39:54.000000000 +0300
+@@ -12,7 +12,7 @@
+ AM_CFLAGS               = $(DEBUGFLAGS)
+ INCLUDES		= -I$(top_srcdir)/src
+ 
+-bin_PROGRAMS		= ts_test ts_calibrate ts_print ts_print_raw ts_harvest
++bin_PROGRAMS		= ts_test ts_calibrate ts_print ts_print_raw ts_harvest ts_finddev inputattach
+ 
+ ts_test_SOURCES		= ts_test.c fbutils.c fbutils.h font_8x8.c font_8x16.c font.h
+ ts_test_LDADD		= $(top_builddir)/src/libts.la
+@@ -27,4 +27,10 @@
+ ts_calibrate_LDADD	= $(top_builddir)/src/libts.la
+ 
+ ts_harvest_SOURCES	= ts_harvest.c fbutils.c fbutils.h testutils.c testutils.h font_8x8.c font_8x16.c font.h
+-ts_harvest_LDADD		= $(top_builddir)/src/libts.la
++ts_harvest_LDADD	= $(top_builddir)/src/libts.la
++
++ts_finddev_SOURCES      = ts_finddev.c
++ts_finddev_LDADD        = $(top_builddir)/src/libts.la
++
++inputattach_SOURCES     = inputattach.c
++inputattach_LDADD       =
+diff -Naur tslib-org/tests/inputattach.c tslib-1.0/tests/inputattach.c
+--- tslib-org/tests/inputattach.c	1970-01-01 02:00:00.000000000 +0200
++++ tslib-1.0/tests/inputattach.c	2007-05-07 17:36:37.000000000 +0300
+@@ -0,0 +1,611 @@
++/*
++ * $Id: inputattach.c,v 1.24 2006/02/08 12:19:31 vojtech Exp $
++ *
++ *  Copyright (c) 1999-2000 Vojtech Pavlik
++ *
++ *  Sponsored by SuSE
++ *
++ *  Twiddler support Copyright (c) 2001 Arndt Schoenewald
++ *  Sponsored by Quelltext AG (http://www.quelltext-ag.de), Dortmund, Germany
++ */
++
++/*
++ * Input line discipline attach program
++ */
++
++/*
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or 
++ * (at your option) any later version.
++ * 
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ * 
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
++ * 
++ * Should you need to contact me, the author, you can do so either by
++ * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:
++ * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic
++ */
++ 
++/* softa note: 
++cvs version is here:
++http://cvs.sourceforge.net/viewcvs.py/ *checkout* /linuxconsole/ruby/utils/inputattach.c
++*/
++
++#include <linux/serio.h>
++
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <sys/ioctl.h>
++#include <sys/time.h>
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <fcntl.h>
++#include <termios.h>
++#include <string.h>
++#include <assert.h>
++#include <ctype.h>
++
++// softa patch!
++/*
++ * Serio types
++ */
++#ifndef SERIO_UNKNOWN
++  #define SERIO_UNKNOWN   0x00
++#endif
++#ifndef SERIO_MSC
++  #define SERIO_MSC       0x01
++#endif
++#ifndef SERIO_SUN
++  #define SERIO_SUN       0x02
++#endif
++#ifndef SERIO_MS
++  #define SERIO_MS        0x03
++#endif
++#ifndef SERIO_MP
++  #define SERIO_MP        0x04
++#endif
++#ifndef SERIO_MZ
++  #define SERIO_MZ        0x05
++#endif
++#ifndef SERIO_MZP
++  #define SERIO_MZP       0x06
++#endif
++#ifndef SERIO_MZPP
++  #define SERIO_MZPP      0x07
++#endif
++#ifndef SERIO_VSXXXAA
++  #define SERIO_VSXXXAA   0x08
++#endif
++#ifndef SERIO_SUNKBD
++  #define SERIO_SUNKBD    0x10
++#endif
++#ifndef SERIO_WARRIOR
++  #define SERIO_WARRIOR   0x18
++#endif
++#ifndef SERIO_SPACEORB
++  #define SERIO_SPACEORB  0x19
++#endif
++#ifndef SERIO_MAGELLAN
++  #define SERIO_MAGELLAN  0x1a
++#endif
++#ifndef SERIO_SPACEBALL
++  #define SERIO_SPACEBALL 0x1b
++#endif
++#ifndef SERIO_GUNZE
++  #define SERIO_GUNZE     0x1c
++#endif
++#ifndef SERIO_IFORCE
++  #define SERIO_IFORCE    0x1d
++#endif
++#ifndef SERIO_STINGER
++  #define SERIO_STINGER   0x1e
++#endif
++#ifndef SERIO_NEWTON
++  #define SERIO_NEWTON    0x1f
++#endif
++#ifndef SERIO_STOWAWAY
++  #define SERIO_STOWAWAY  0x20
++#endif
++#ifndef SERIO_H3600
++  #define SERIO_H3600     0x21
++#endif 
++#ifndef SERIO_PS2SER
++  #define SERIO_PS2SER    0x22
++#endif
++#ifndef SERIO_TWIDKBD
++  #define SERIO_TWIDKBD   0x23
++#endif
++#ifndef SERIO_TWIDJOY
++  #define SERIO_TWIDJOY   0x24
++#endif
++#ifndef SERIO_HIL
++  #define SERIO_HIL       0x25
++#endif
++#ifndef SERIO_SNES232
++  #define SERIO_SNES232   0x26
++#endif
++#ifndef SERIO_SEMTECH
++  #define SERIO_SEMTECH   0x27
++#endif
++#ifndef SERIO_LKKBD
++  #define SERIO_LKKBD     0x28
++#endif
++#ifndef SERIO_ELO
++  #define SERIO_ELO       0x29
++#endif
++#ifndef SERIO_MICROTOUCH
++  #define SERIO_MICROTOUCH        0x30
++#endif
++#ifndef SERIO_PENMOUNT
++  #define SERIO_PENMOUNT  0x31
++#endif
++#ifndef SERIO_TOUCHRIGHT
++  #define SERIO_TOUCHRIGHT        0x32
++#endif
++#ifndef SERIO_TOUCHWIN
++  #define SERIO_TOUCHWIN  0x33
++#endif
++// end softa patch!
++
++int readchar(int fd, unsigned char *c, int timeout)
++{
++	struct timeval tv;
++	fd_set set;
++	
++	tv.tv_sec = 0;
++	tv.tv_usec = timeout * 1000;
++
++	FD_ZERO(&set);
++	FD_SET(fd, &set);
++
++	if (!select(fd+1, &set, NULL, NULL, &tv)) return -1;
++	if (read(fd, c, 1) != 1) return -1;
++
++	return 0;
++}
++
++
++
++void setline(int fd, int flags, int speed)
++{
++	struct termios t;
++
++	tcgetattr(fd, &t);
++
++	t.c_cflag = flags | CREAD | HUPCL | CLOCAL;
++	t.c_iflag = IGNBRK | IGNPAR;
++	t.c_oflag = 0;
++	t.c_lflag = 0;
++	t.c_cc[VMIN ] = 1;
++	t.c_cc[VTIME] = 0;
++
++	cfsetispeed(&t, speed);
++	cfsetospeed(&t, speed);
++
++	tcsetattr(fd, TCSANOW, &t);
++}
++
++int logitech_command(int fd, char *c)
++{
++	int i;
++	unsigned char d;
++	for (i = 0; c[i]; i++) {
++		write(fd, c + i, 1);
++		if (readchar(fd, &d, 1000))
++			return -1;
++		if (c[i] != d)
++			return -1;
++	}
++	return 0;
++}
++
++int magellan_init(int fd, long *id, long *extra)
++{
++	write(fd, "m3\rpBB\rz\r", 9);
++	return 0;
++}
++
++int warrior_init(int fd, long *id, long *extra)
++{
++	if (logitech_command(fd, "*S")) return -1;
++	setline(fd, CS8, B4800);
++	return 0;
++}
++
++int spaceball_waitchar(int fd, unsigned char c, unsigned char *d, int timeout)
++{
++	unsigned char b = 0;
++
++	while (!readchar(fd, &b, timeout)) {
++		if (b == 0x0a) continue;
++		*d++ = b;
++		if (b == c) break;
++	}
++
++	*d = 0;
++
++	return -(b != c);
++}
++
++int spaceball_waitcmd(int fd, char c, char *d)
++{
++	int i;
++
++	for (i = 0; i < 8; i++) {
++		if (spaceball_waitchar(fd, 0x0d, d, 1000))
++			return -1;
++		if (d[0] == c)
++			return 0;
++	}
++
++	return -1;
++}
++
++int spaceball_cmd(int fd, char *c, char *d)
++{
++	int i;
++
++	for (i = 0; c[i]; i++)
++		write(fd, c + i, 1);
++	write(fd, "\r", 1);
++
++	i = spaceball_waitcmd(fd, toupper(c[0]), d);
++
++	return i;
++}
++
++#define SPACEBALL_1003		1
++#define SPACEBALL_2003B		3
++#define SPACEBALL_2003C		4
++#define SPACEBALL_3003C		7
++#define SPACEBALL_4000FLX	8
++#define SPACEBALL_4000FLX_L 	9
++
++int spaceball_init(int fd, long *id, long *extra)
++{
++	char r[64];
++
++	if (spaceball_waitchar(fd, 0x11, r, 4000) ||
++	    spaceball_waitchar(fd, 0x0d, r, 1000))
++		return -1;
++
++	if (spaceball_waitcmd(fd, '@', r))
++		return -1; 
++
++	if (strncmp("@1 Spaceball alive", r, 18))
++		return -1;
++
++	if (spaceball_waitcmd(fd, '@', r))
++		return -1; 
++
++	if (spaceball_cmd(fd, "hm", r))
++		return -1;
++
++	if (!strncmp("Hm2003B", r, 7))
++		*id = SPACEBALL_2003B;
++	if (!strncmp("Hm2003C", r, 7))
++		*id = SPACEBALL_2003C;
++	if (!strncmp("Hm3003C", r, 7))
++		*id = SPACEBALL_3003C;
++
++	if (!strncmp("HvFirmware", r, 10)) {
++
++		if (spaceball_cmd(fd, "\"", r))
++			return -1;
++
++		if (strncmp("\"1 Spaceball 4000 FLX", r, 21))
++			return -1;
++
++		if (spaceball_waitcmd(fd, '"', r))
++			return -1; 
++
++		if (strstr(r, " L "))
++			*id = SPACEBALL_4000FLX_L;
++		else
++			*id = SPACEBALL_4000FLX;
++
++		if (spaceball_waitcmd(fd, '"', r))
++			return -1; 
++
++		if (spaceball_cmd(fd, "YS", r))
++        	        return -1;
++
++		if (spaceball_cmd(fd, "M", r))
++        	        return -1;
++
++		return 0;
++	}
++
++	if (spaceball_cmd(fd, "P@A@A", r) ||
++	    spaceball_cmd(fd, "FT@", r)   ||
++	    spaceball_cmd(fd, "MSS", r))
++		return -1;
++
++	return 0;
++}
++
++int stinger_init(int fd, long *id, long *extra)
++{
++	int i;
++	unsigned char c;
++	unsigned char *response = "\r\n0600520058C272";
++
++	if (write(fd, " E5E5", 5) != 5)		/* Enable command */
++		return -1; 
++
++	for (i = 0; i < 16; i++)		/* Check for Stinger */
++		if (readchar(fd, &c, 200) || (c != response[i])) 
++			return -1;
++
++	return 0;
++}
++
++int mzp_init(int fd, long *id, long *extra)
++{
++	if (logitech_command(fd, "*X*q")) return -1;
++	setline(fd, CS8, B9600);
++	return 0;
++}
++
++int newton_init(int fd, long *id, long *extra)
++{
++  int i;
++  unsigned char c;
++  unsigned char response[35] =
++  { 0x16, 0x10, 0x02, 0x64, 0x5f, 0x69, 0x64, 0x00,
++    0x00, 0x00, 0x0c, 0x6b, 0x79, 0x62, 0x64, 0x61,
++    0x70, 0x70, 0x6c, 0x00, 0x00, 0x00, 0x01, 0x6e,
++    0x6f, 0x66, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x10,
++    0x03, 0xdd, 0xe7 };
++
++  for (i = 0; i < 35; i++)
++    if (readchar(fd, &c, 400) || (c != response[i]))
++      return -1;
++
++  return 0;
++}
++
++int twiddler_init(int fd, long *id, long *extra)
++{
++	unsigned char c[10];
++	int count, line;
++
++	/* Turn DTR off, otherwise the Twiddler won't send any data. */
++	if (ioctl(fd, TIOCMGET, &line)) return -1;
++	line &= ~TIOCM_DTR;
++	if (ioctl(fd, TIOCMSET, &line)) return -1;
++
++	/* Check whether the device on the serial line is the Twiddler.
++	 *
++	 * The Twiddler sends data packets of 5 bytes which have the following
++	 * properties: the MSB is 0 on the first and 1 on all other bytes, and
++	 * the high order nibble of the last byte is always 0x8.
++	 *
++	 * We read and check two of those 5 byte packets to be sure that we
++	 * are indeed talking to a Twiddler. */
++
++	/* Read at most 5 bytes until we find one with the MSB set to 0 */
++	for (count = 0; count < 5; count++) {
++		if (readchar(fd, c+0, 500)) return -1;
++		if ((c[0] & 0x80) == 0) break;
++	}
++
++	if (count == 5) {
++		/* Could not find header byte in data stream */
++		return -1;
++	}
++
++	/* Read remaining 4 bytes plus the full next data packet */
++	for (count = 1; count < 10; count++) {
++		if (readchar(fd, c+count, 500)) return -1;
++	}
++
++	/* Check whether the bytes of both data packets obey the rules */
++	for (count = 1; count < 10; count++) {
++		if ((count % 5 == 0 && (c[count] & 0x80) != 0)
++		    || (count % 5 == 4 && (c[count] & 0xF0) != 0x80)
++		    || (count % 5 != 0 && (c[count] & 0x80) != 0x80)) {
++		    	/* Invalid byte in data packet */
++			return -1;
++		}
++	}
++
++	return 0;
++}
++
++int penmount_init(int fd, long *id, long *extra)
++{
++	unsigned char init_cmd[5] = { 0xF2, 0x00, 0x00, 0x00, 0x00 };
++	unsigned char start_cmd[5] = { 0xF1, 0x00, 0x00, 0x00, 0x00 };
++	unsigned char c[10];
++	int count;
++	
++	/* try to initialize device */
++	if (write( fd, init_cmd, 5 ) != 5)
++		return -1;
++		
++	/* read the responce */
++	for (count = 0; count < 5; count ++) {
++		if (readchar(fd, c+0, 500)) return -1;
++		if (c[0] == 0xf2) break;
++	}
++	
++	if (readchar(fd, c+1, 500)) return -1;
++	if (c[1] != 0xd9) return -1;
++	
++	if (readchar(fd, c+2, 500)) return -1;
++	if (c[2] != 0x0a) return -1;
++	
++	/* the device is present! start it! */
++	if (write( fd, start_cmd, 5 ) != 5)
++		return -1;
++		
++	return 0;
++}
++
++int dump_init(int fd, long *id, long *extra)
++{
++	unsigned char c, o = 0;
++
++	c = 0x80;
++
++	if (write(fd, &c, 1) != 1)         /* Enable command */
++                return -1;
++
++	while (1)
++		if (!readchar(fd, &c, 1)) {
++			printf("%02x (%c) ", c, ((c > 32) && (c < 127)) ? c : 'x');
++			o = 1;
++		} else {
++			if (o) {
++				printf("\n");
++				o = 0;
++			}
++		}
++}
++
++struct input_types {
++	char name[16];
++	char name2[16];
++	int speed;
++	int flags;
++	unsigned long type;
++	unsigned long id;
++	unsigned long extra;
++	int flush;
++	int (*init)(int fd, long *id, long *extra);
++};
++
++struct input_types input_types[] = {
++
++{ "--sunkbd",		"-skb",		B1200, CS8,			SERIO_SUNKBD,	0,	0,	1,	NULL },
++{ "--lkkbd",		"-lk",		B4800, CS8|CSTOPB,		SERIO_LKKBD,	0,	0,	1,	NULL },
++{ "--vsxxx-aa",		"-vs",		B4800, CS8|CSTOPB|PARENB|PARODD,SERIO_VSXXXAA,	0,	0,	1,	NULL },
++{ "--spaceorb",		"-orb",		B9600, CS8,			SERIO_SPACEORB,	0,	0,	1,	NULL },
++{ "--spaceball",	"-sbl",		B9600, CS8,			SERIO_SPACEBALL,0,	0,	0,	spaceball_init },
++{ "--magellan",		"-mag",		B9600, CS8 | CSTOPB | CRTSCTS,	SERIO_MAGELLAN,	0,	0,	1,	magellan_init },
++{ "--warrior",		"-war",		B1200, CS7 | CSTOPB,		SERIO_WARRIOR,	0,	0,	1,	warrior_init },
++{ "--stinger",		"-sting",	B1200, CS8,			SERIO_STINGER,	0,	0,	1,	stinger_init },
++{ "--mousesystems",	"-msc",		B1200, CS8,			SERIO_MSC,	0,	0x01,	1,	NULL },
++{ "--sunmouse",		"-sun",		B1200, CS8,			SERIO_SUN,	0,	0x01,	1,	NULL },
++{ "--microsoft",	"-bare",	B1200, CS7,			SERIO_MS,	0,	0,	1,	NULL },
++{ "--mshack",		"-ms",		B1200, CS7,			SERIO_MS,	0,	0x01,	1,	NULL },
++{ "--mouseman",		"-mman",	B1200, CS7,			SERIO_MP,	0,	0x01,	1,	NULL },
++{ "--intellimouse",	"-ms3",		B1200, CS7,			SERIO_MZ,	0,	0x11,	1,	NULL },
++{ "--mmwheel",		"-mmw",		B1200, CS7 | CSTOPB,		SERIO_MZP,	0,	0x13,	1,	mzp_init },
++{ "--iforce",		"-ifor",	B38400, CS8,			SERIO_IFORCE,	0,	0,	0,	NULL },
++{ "--newtonkbd",        "-newt",        B9600, CS8,                     SERIO_NEWTON,	0,	0,	0,      newton_init },
++{ "--h3600ts",          "-ipaq",     	B115200, CS8,                   SERIO_H3600,	0,	0,	0,      NULL },
++{ "--stowawaykbd",      "-ipaqkbd",     B115200, CS8,                   SERIO_STOWAWAY, 0,	0,	0,      NULL },
++{ "--ps2serkbd",	"-ps2ser",	B1200, CS8,			SERIO_PS2SER,	0,	0,	1,	NULL },
++{ "--twiddler",		"-twid",	B2400, CS8,			SERIO_TWIDKBD,	0,	0,	0,	twiddler_init },
++{ "--twiddler-joy",	"-twidjoy",	B2400, CS8,			SERIO_TWIDJOY,	0,	0,	0,	twiddler_init },
++{ "--elotouch",		"-elo",		B9600, CS8 | CRTSCTS,		SERIO_ELO,	0,	0,	0,	NULL },
++{ "--elo4002",		"-elo6b",	B9600, CS8 | CRTSCTS,		SERIO_ELO,	1,	0,	0,	NULL },
++{ "--elo271-140",	"-elo4b",	B9600, CS8 | CRTSCTS,		SERIO_ELO,	2,	0,	0,	NULL },
++{ "--elo261-280",	"-elo3b",	B9600, CS8 | CRTSCTS,		SERIO_ELO,	3,	0,	0,	NULL },
++{ "--dump",		"-dump",	B2400, CS8, 			0,		0,	0,	0,	dump_init },
++{ "--dmc9000",          "-dmc",         B19200, CS8,			SERIO_PENMOUNT, 0,      0,      0,      penmount_init },
++{ "", "", 0, 0 }
++
++};
++
++int main(int argc, char **argv)
++{
++	unsigned long devt;
++	int ldisc;
++        int type;
++	long id, extra;
++        int fd;
++	char c;
++
++        if (argc < 2 || argc > 3 || !strcmp("--help", argv[1])) {
++                puts("");
++                puts("Usage: inputttach <mode> <device>");
++                puts("");
++                puts("Modes:");
++                puts("  --sunkbd        -skb   Sun Type 4 and Type 5 keyboards");
++		puts("  --lkkbd         -lk    DEC LK201 / LK401 keyboards");
++		puts("  --vsxxx-aa      -vs    DEC VSXXX-AA / VSXXX-GA mouse and VSXXX-AB tablet");
++                puts("  --spaceorb      -orb   SpaceOrb 360 / SpaceBall Avenger");
++		puts("  --spaceball     -sbl   SpaceBall 2003 / 3003 / 4000 FLX");
++                puts("  --magellan      -mag   Magellan / SpaceMouse");
++                puts("  --warrior       -war   WingMan Warrior");
++		puts("  --stinger       -stng  Gravis Stinger");
++		puts("  --mousesystems  -msc   3-button Mouse Systems mice");
++		puts("  --sunmouse      -sun   3-button Sun mice");
++		puts("  --microsoft     -bare  2-button Microsoft mice");
++		puts("  --mshack        -ms    3-button mice in Microsoft mode");
++		puts("  --mouseman      -mman  3-button Logitech and Genius mice");
++		puts("  --intellimouse  -ms3   Microsoft IntelliMouse");
++		puts("  --mmwheel       -mmw   Logitech mice with 4-5 buttons or wheel");
++		puts("  --iforce        -ifor  I-Force joysticks and wheels");
++                puts("  --h3600ts       -ipaq  Ipaq h3600 touchscreen");
++		puts("  --stowawaykbd   -ipaqkbd  Stowaway keyboard");
++		puts("  --ps2serkbd     -ps2ser PS/2 via serial keyboard");
++		puts("  --twiddler      -twid   Handykey Twiddler chording keyboard");
++		puts("  --twiddler-joy  -twidjoy  Handykey Twiddler used as a joystick");
++		puts("  --dmc9000       -dmc   DMC9000/Penpount touchscreen");
++		puts("");
++                return 1;
++        }
++
++        for (type = 0; input_types[type].speed; type++) {
++                if (!strncasecmp(argv[1], input_types[type].name, 16) ||
++			!strncasecmp(argv[1], input_types[type].name2, 16))
++                        break;
++        }
++
++	if (!input_types[type].speed) {
++		fprintf(stderr, "inputattach: invalid mode\n");
++		return 1;
++	}
++
++	if ((fd = open(argv[2], O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0) {
++		perror("inputattach");
++		return 1;
++	}
++
++	setline(fd, input_types[type].flags, input_types[type].speed);
++
++	if (input_types[type].flush)
++		while (!readchar(fd, &c, 100));
++
++	id = input_types[type].id;
++	extra = input_types[type].extra;
++
++	if (input_types[type].init && input_types[type].init(fd, &id, &extra)) {
++		fprintf(stderr, "inputattach: device initialization failed\n");
++		return 1;
++	}
++
++	ldisc = N_MOUSE;
++	if(ioctl(fd, TIOCSETD, &ldisc)) {
++		fprintf(stderr, "inputattach: can't set line discipline\n"); 
++		return 1;
++	}
++
++	devt = input_types[type].type | (id << 8) | (extra << 16);
++
++	if(ioctl(fd, SPIOCSTYPE, &devt)) {
++		fprintf(stderr, "inputattach: can't set device type\n");
++		return 1;
++	}
++
++	read(fd, NULL, 0);
++
++	ldisc = 0;
++	ioctl(fd, TIOCSETD, &ldisc);
++	close(fd);
++
++	return 0;
++}
+diff -Naur tslib-org/tests/ts_finddev.c tslib-1.0/tests/ts_finddev.c
+--- tslib-org/tests/ts_finddev.c	1970-01-01 02:00:00.000000000 +0200
++++ tslib-1.0/tests/ts_finddev.c	2007-05-07 17:36:37.000000000 +0300
+@@ -0,0 +1,75 @@
++/*
++ *  tslib/src/ts_print.c
++ *
++ *  Derived from tslib/src/ts_test.c by Douglas Lowder
++ *  Just prints touchscreen events -- does not paint them on framebuffer
++ *
++ * This file is placed under the GPL.  Please see the file
++ * COPYING for more details.
++ *
++ * Basic test program for touchscreen library.
++ */
++#include <stdio.h>
++#include <stdlib.h>
++#include <signal.h>
++#include <sys/fcntl.h>
++#include <sys/ioctl.h>
++#include <sys/mman.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <unistd.h>
++
++#include "tslib.h"
++
++void usage( int argc, char** argv ) {
++	printf( "Usage: %s device_name wait_for_sec\n", argv[0] );
++	printf( "\tdevice_name  - tdevice to probe, example /dev/input/event0\n" );
++	printf( "\twait_for_sec - wait seconds for touch event, if 0 - dont wait!\n" );
++	printf( "\tReturn codes:\n" );
++	printf( "\t  0          - timeout expired without receiving event.\n" );
++	printf( "\t               But this maybe is TouchScreen.\n" );
++	printf( "\t -1          - this is NOT TouchScreen device!\n" );
++	printf( "\t  1          - this is TouchScreen for shure!\n" );  
++	exit(-1);
++}
++
++void alarm_handler( int sig ) {
++	// time is expired!
++	exit(0);
++}
++
++int main( int argc, char** argv )
++{
++	struct tsdev *ts;
++	struct ts_sample samp;
++	char *tsdevice=NULL;
++	int waitsec;
++	int ret;
++	
++	if (argc != 3)
++		usage( argc, argv );
++		
++	tsdevice = argv[1];
++	waitsec = atoi( argv[2] );
++	if (waitsec < 0)
++		usage( argc, argv );
++		
++	ts = ts_open( tsdevice, 0 );
++	if (!ts)
++		return -1;
++	if (ts_config(ts))
++		return -1;
++		
++	if (!waitsec) {
++		return 0;
++	}
++		
++	printf( "Probe device %s, Please Touch Screen Anywhere in %i seconds! ... \n", tsdevice, waitsec );
++	signal( SIGALRM, alarm_handler );
++	alarm( waitsec );
++	ret = ts_read_raw(ts, &samp, 1 );
++	if (ret)
++		return 1;
++		
++	return -1;
++}
-- 
2.7.4

